package defpackage;

/* renamed from: ackx */
public final class ackx {
    public static String a() {
        return "/*\n A vertex-shader-based particle system. Position and other random attributes are computed entirely in the vertex shader.\n Attribute data consists of a 'part' identifier (which corner of the particle is this) and a 'particleID', which\n serves as a random seed.\n */\n\nprecision highp float;\n\nuniform highp float time;\nuniform highp float lastParticleEmissionTime;\nuniform highp float maxParticleID;\nuniform mediump float aspectRatio;\nuniform mediump float seedOffset;\n\n// uniform definitions in SCXWeather.h\n\nuniform float emissionBurst;\nuniform float skipParticleProbability;\n\nuniform float fadeInOverTime;\nuniform float fadeOutOverTime;\nuniform float particleLifetime;\nuniform float particleLifetimeVariance;\n\nuniform vec4 emissionRect;\nuniform float angle;\nuniform float angleVariance;\nuniform float velocity;\nuniform float velocityVariance;\n\nuniform int frameCount;\nuniform float frameDuration;\n\nuniform float imageAspectRatio;\nuniform float scale;\nuniform float scaleVariance;\n\nuniform float flutterAmplitude;\nuniform float flutterMinPeriod;\nuniform float flutterMaxPeriod;\n\nuniform float rotationsPerSecond;\nuniform float rotationsPerSecondVariance;\nuniform float rotateIn3D;\n\nuniform vec4 color;\nuniform float alphaVariance;\n\nconst float twoPi = 6.2831853072;\n\nattribute float vertexPart;\n/*\n vertex part: what part of the particle is this vertex?\n 0: upper left\n 1: lower left\n 2: lower right\n 3: upper right\n */\n\nattribute highp float particleID;\n/*\n particle ID: 0..1 identifier for this particle. Determines a particle's emission offset in a generation.\n */\n\nvarying lowp vec2 faceCoord; // [0..1]\nvarying lowp float kAlpha;\n\n// 'canonical' GLSL PRNG from https://thebookofshaders.com/10/\n// for best results, seed values should be in the -1..1 range\nfloat random(vec2 st) {\n    highp float x = fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n                 43758.5453123);\n    return (x - 0.5) * 2.0;\n}\nfloat random_0_1(vec2 st) {\n    highp float x = fract(sin(dot(st.xy,\n                                  vec2(12.9898,78.233)))*\n                          43758.5453123);\n    return x;\n}\n\n// these 'feature seeds' are added to the particle instance seed to compute\n// values for random particle-specific features.\n// the PRNG works best in the region of -1..1, so they should be small:\nconst mediump float LIFETIME_FEATURE_SEED = 0.01;\nconst mediump float SCALE_FEATURE_SEED = 0.02;\nconst mediump float INITIAL_X_FEATURE_SEED = 0.03;\nconst mediump float INITIAL_Y_FEATURE_SEED = 0.04;\nconst mediump float ANGLE_FEATURE_SEED = 0.05;\nconst mediump float VELOCITY_FEATURE_SEED = 0.06;\nconst mediump float ROTATION_FEATURE_SEED = 0.07;\nconst mediump float ALPHA_FEATURE_SEED = 0.08;\nconst mediump float FLUTTER_PERIOD_FEATURE_SEED = 0.09;\nconst mediump float FLUTTER_OFFSET_FEATURE_SEED = 0.10;\nconst mediump float ROTATION_TIME_OFFSET_FEATURE_SEED = 0.11;\nconst mediump float SKIP_PARTICLE_FEATURE_SEED = 0.12;\n\nfloat randWithVariance(highp vec2 particleSeed, float featureSeed, float value, float variance) {\n    return value + variance * random(particleSeed + featureSeed);\n}\n\nvec2 rotateVec(vec2 vec, float angle) {\n    return vec2(vec.x * cos(angle) - vec.y * sin(angle), vec.x * sin(angle) + vec.y * cos(angle));\n}\n\nfloat adjustTextureYCoordForSpriteAnimation(float y, float timeSinceEmission) {\n    float fc = float(frameCount);\n    float frameIndex = floor(mod(timeSinceEmission / frameDuration, fc));\n    return (y + frameIndex) / fc;\n}\n\nvoid main()\n{\n    float generationDuration = particleLifetime + particleLifetimeVariance;\n    float emissionOffsetWithinGeneration = pow(particleID / maxParticleID, emissionBurst) * generationDuration;\n    \n    float timeSinceEmission = mod(time - emissionOffsetWithinGeneration, generationDuration);\n    float emissionTime = time - timeSinceEmission;\n    float generation = floor(emissionTime / generationDuration);\n    highp vec2 particleSeed = vec2(particleID, 1.0 / (generation + 1.0)) + seedOffset;\n    \n    float lifetime = randWithVariance(particleSeed, LIFETIME_FEATURE_SEED, particleLifetime, particleLifetimeVariance);\n    \n    if (emissionTime < 0.0 || (lastParticleEmissionTime > 0.0 && emissionTime > lastParticleEmissionTime)) {\n        kAlpha = 0.0;\n    } else {\n        kAlpha = randWithVariance(particleSeed, ALPHA_FEATURE_SEED, 1.0, alphaVariance);\n        kAlpha *= clamp(timeSinceEmission / fadeInOverTime, 0.0, 1.0);\n        kAlpha *= clamp((lifetime - timeSinceEmission) / fadeOutOverTime, 0.0, 1.0);\n    }\n    \n    if (random_0_1(particleSeed + SKIP_PARTICLE_FEATURE_SEED) < skipParticleProbability) {\n        kAlpha = 0.0;\n    }\n    \n    mediump float scale = randWithVariance(particleSeed, SCALE_FEATURE_SEED, scale, scaleVariance);\n\n    vec2 initialPosition = emissionRect.xy + vec2(random_0_1(particleSeed + INITIAL_X_FEATURE_SEED), random_0_1(particleSeed + INITIAL_Y_FEATURE_SEED)) * emissionRect.zw;\n    mediump float particleAngle = randWithVariance(particleSeed, ANGLE_FEATURE_SEED, angle, angleVariance);\n    mediump float particleVelocity = randWithVariance(particleSeed, VELOCITY_FEATURE_SEED, velocity, velocityVariance);\n    mediump float distance = generationDuration * particleVelocity;\n    \n    vec2 displacement = vec2(0.0, distance);\n    if (flutterAmplitude > 0.0) {\n        float flutterPeriod = mix(flutterMinPeriod, flutterMaxPeriod, random_0_1(particleSeed + FLUTTER_PERIOD_FEATURE_SEED));\n        float flutterPhase = random_0_1(particleSeed + FLUTTER_OFFSET_FEATURE_SEED) * twoPi;\n        displacement.x += sin(timeSinceEmission / flutterPeriod + flutterPhase) * flutterAmplitude;\n    }\n    displacement = rotateVec(displacement, particleAngle);\n    \n    vec2 finalPosition = initialPosition + displacement;\n    vec2 pos = mix(initialPosition, finalPosition, timeSinceEmission / generationDuration);\n    \n    mediump float particleRotationPerSecond = randWithVariance(particleSeed, ROTATION_FEATURE_SEED, rotationsPerSecond, rotationsPerSecondVariance);\n    float rotationTimeOffset = timeSinceEmission + generationDuration * random_0_1(particleSeed + ROTATION_TIME_OFFSET_FEATURE_SEED);\n    mediump float particleRotation = particleRotationPerSecond > 0.0 ? particleRotationPerSecond * rotationTimeOffset : 0.0;\n    mediump float rotation3D = particleRotation * rotateIn3D;\n    \n    mediump float spriteRotation = particleRotation + particleAngle;\n    \n    lowp int part = int(vertexPart);\n    float u = (part == 0 || part == 1) ? 0.0 : 1.0;\n    float v = (part == 0 || part == 2) ? 0.0 : 1.0;\n\n    vec2 localPos = vec2((u - 0.5) * scale * imageAspectRatio, (v - 0.5) * scale);\n    // give the effect of 3d location without projection by scaling along one axis:\n    localPos.x *= cos(rotation3D);\n    // apply 2d rotation:\n    localPos = rotateVec(localPos, spriteRotation);\n\n    vec2 finalPos = pos + localPos;\n\n    gl_Position = vec4(finalPos.x / aspectRatio, finalPos.y, 0.0, 1.0);\n    float vAdjusted = adjustTextureYCoordForSpriteAnimation(v, timeSinceEmission);\n    faceCoord = vec2(u, 1.0 - vAdjusted);\n}";
    }

    public static String b() {
        return "varying lowp vec2 faceCoord; // [0..1]\nvarying lowp float kAlpha;\n\nuniform sampler2D texture;\nuniform lowp vec4 color;\n\nvoid main()\n{\n    gl_FragColor = texture2D(texture, faceCoord) * color * kAlpha;\n}";
    }
}
